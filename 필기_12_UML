# Summerclass_2021

Star UML 체험해 보기


클래스 다이어그램을 사용해서 UML 을 그리는 방법을 생각해 보도록 한다



- 책에 나와있는 대로 클래스 표를 작성한다.
- Generalization 기능으로 상속을 표현한다

- c++ 플러그인을 사용하여 cpp 코드를 생성한다


이렇게 UML 을 사용하여 코드를 생성한 뒤에도 손질을 해 줘야 한다 하지만 전처리기를 포함한 기본적인 틀 정도는 만들어 준다








상속 - 위임


- 위임 : 부모 클래스의 함수를 자식 클래스가 사용하는 것이다.
- Pesrson::setid() //Delegation

- Student 객체가 위와 같이 Person 부모클래스가 가지고 있는 기능을 사용하는것을 Delegation 이라고 한다





- 생성자, 소멸자, 연산자 오버로딩 같은 경우, 부모에서 자식으로 상속이 되지 않는다 !!
- 다만, 생성자의 경우 앞서 배운 생성자 리스트의 문법에서 자식 클래스의 생성자가 부모 클래스의 생성자를 call 할 수 있다 



- 헤더파일에서 생성자를 만들고 행에 알트 앤터? 우클릭? 을 해서 정의 만들기를 하면 적절한 .cpp 파일에 함수가 생기고 코드를 바로 작성할 수 있다 





우분투로 분할컴파일

- 1개의 cpp 파일이 아니라 객체지향프로그래밍을 하기 위해서는 여러 cpp 파일을 컴파일 해야 한다
 
 g++ Person.cpp app.cpp -o person.o
 
 - 위와 같이 하면 Person.cpp 의 오브젝트 파일 person.o 가 생성된다
 - 
 
 
 
 
상속관계

- 상속관계에도 접근지정자가 있다. 

class Student : public person{
...
}

- 접근지정자는 상속 받는 자식 클래스에서 사용하며, 접근지정자에 따라 접근할 수 있는 범위가 달라진다




연관관계

- Assosiation : 가령 Person 은 특정 Address 안에 살고 있을 수 있다. 이때 Address 는 한번에 여러 Person (가령 가족과 같이) 과 '연관관계' 를 가질 수 있다.
- 또다른 ex) Course 하나는 40명의 Student 가 들을 수 있다. 그리고 한 Student 는 0~6개의 Course 를 수강할 수 있다. 이것도 연관관계이다.


- Aggregation : 멤버변수 자리에 해당 클래스의 객체를 선언하는 것이다. 컨테이니와 컨테이너 사이의 수명 연관성이 없다. (가령 탈부착 가능한 컴퓨터와 그 부품들)
ㄴ>텅빈 화살표

- Composition : 컨테이너의 수명이 컨테이니의 수명에 연관이 있는 경우 (가령 사람과 그 사람의 이름, 차량과 차량의 부품들)
ㄴ> 꽉찬 화살표



- Dependency : A 가 B 를 일방적으로 사용하는 경우 : 영수증과 참고서, 주요 메서드의 매개변수로 받는 경우가 있다
ㄴ> 점선 화살표 관계




======
상속의 접근지정자 관계

우선 부모 클래스에선 pub, prt, prv 객체들을 멤버로 모두 지니고 있는 상태라고 하자. 

Public 상속의 경우 : 모든 부모 클래스의 접근지정자를 본래 상태 그대로 가져오는 것이다.
Protected 상속의 경우 : 모든 부모클래스 멤버객체들이, 자식 객체에서 Protected 를 최소값으로 선언된 것 처럼 된다.
Private 상속의 경우 : 자식클래스기 가져온 모든 Attribute 들이, Private 하게 선언된 것 처럼 동작하는 것이다.


1. Public 상속의 경우 : 모든 부모 클래스의 접근지정자를 본래 상태 그대로 가져오는 것이다.

- pub 는 외부에서도 당연히 접근이 가능한 public 멤버이다. 자식 클래스는 당연히 접근할 수 있으며, main 에서 만든 자식객체를 통해서도 조작이 가능하다.
- prv 는 오직 본인과 같은 클래스만 접근이 가능하다. 외부에서도, 자식도 접근할 수 없다.
- prt 는 이제 자식 클래스에서 한정적으로 접근이 가능한 객체라고 하겠다. 자식객체의 메서드를 통해서는 직접접근할 수 있으나, main 에서 직접조작은 불가하다.

2. Protected 상속의 경우 : 모든 부모클래스 멤버객체들이, 자식 객체에서 Protected 를 최소값으로 선언된 것 처럼 된다.

- 이제 모든 변수들이, main 에서 직접접근 하는 것은 불가능하다.
- prv 는 자식 객체가 조작할 수 없다.
- 하지만 prt 와 pub 는 자식을 통해서 조작할 수 있다.

3. Private 상속의 경우 : 자식클래스기 가져온 모든 Attribute 들이, Private 하게 선언된 것 처럼 동작하는 것이다.

- 모든 변수들이 외부에선 직접접근할 수 없다.
- prv 는 자식이 여전히 만질 수 없다.
- 허나 pub 와 prt 는 자식을 통해서는 조작할 수 있다. 



Q. 그렇다면, 2 와 3 의 차이는 무엇인가? 외부와 자식 클래스의 접근조건이 똑같지 않은가

A. 답은, 이것을 한번 더 자식 클래스가 상속 받을 때 생긴다.

- private 하게 상속된 2세대와, protected 하게 상속된 2세대가 있다고 하자. 이제 3세대가 이들을 각각 public 상속하여 그 차이점을 알아 볼 것이다.

- private 하게 상속된 2세대는, 3세대가 아무것도 조작할 수 없게 한다. 
- protected 하게 상속된 2세대는, 부모로부터 받은 pub 와 prt 를 본인이 조작할 수 있었 던 것처럼 자식을 통해서는 조작 할 수 있도록 념거준다.















