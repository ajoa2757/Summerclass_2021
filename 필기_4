# Summerclass_2021


중간고사 : 오픈북?
- 클래스 기본(X, 기말고사로 패스)
- 반복문 및 함수 
- 오버플로우 & 언더플로우
- 각종 캐스팅 현상들에 대한 파악


===============
cp [파일명1] [파일명2]
...을 통해 파일명1 을 복사한 파일명2 를 생성할 수 있다.


int x(0);

cout<<oct
cout<<x

- 위와 같이 하면, x 가 8진수로 출력된다.
- oct 이외에도 출력 관련 객체를 cout 에 전달하면 여러 포멧이 가능하다.
- 가령 hex 를 전달한 이후 출력하면 16진수 포멧으로 출력된다.

- showbase: 를 전달하면 출력 숫자의 진법이 표시된다.
- 8진법의 경우 특히 0이 붙어 나오고, 16진법은 익히 알고있는 대로 0x 가 붙어 나온다
- C++ 14부터는 이진수 형태를 0b 로 시작하여 표현한다
- 이러한 표현들은 변수에 내가 형태를 갖추어서 넣을 때도 마찬가지

- boolalpha 는 0이면 false 나머지면 true 인 bool 의 출력을 정말 true or false 로 하여 준다



부동소수점 표현

- exp. 와 진수부로 나누어서 비트 표현을 하였었다. 가령 0.01237 을 보자
- 1.237 * e-002 이다. 진수부는 10 이하 1이상의 수로 표현되고, 소수점 2자리 내림은 e-002 로 나타내어진 것이다..

- cout 에 showpoint 객체를 전달하게 되면, 정수뿐인 double 객체도 소수점을 포함하여 나타낸다. 
- 소수점 자리 역시 지정할 수 있다. 
- setw, setfill : setw 함수로 n 을 전달하고, setfill 로 기호를 전달한다.
ㄴ>그럼 무조건 정수가 n 자리까지, 앞에 기호를 채워서 표현된다.

- hex 와 oct 와 같은 출력용 리터럴? 들은 cin 에도 전달하여 마찬가지로 사용할 수 있따. 


oct 와 hex , binary 오가기

- Hex 로 나타낸 수는, 한 자리에 4비트씩 2진수로 쭉 늘릴 수 있다.
- oct 로 나타낸 수는, 한 자리에 3비트씩 2진수로 쭊 늘릴 수 있다.


입력 논리문제

- ffffffff 를 signed int 에 입력하는 상황을 생각해 보자.
case 1 : cin 을 통해 입력한다
ㄴ> 우선 저 비트패턴이 그대로 메모리에 입력되지는 못한다. 1비트 크다.
ㄴ> 저것이 음수로 들어가지 못하고, maximum positive num. 으로 입력된다.

case 2 : 편집기로 직접 0xffffffff 를 입력한다
ㄴ> 이번엔 비트패턴이 그대로 입력된다.
ㄴ> 따라서, 최상위 1비트까지 고지곧대로 입력된다
ㄴ> 그래서 이번엔 출력 시 정상적으로 -1 을 얻는다


::n vs n
- 전역 스코프에 있는 n 은 ::n 으로 소환할 수 있다
- 일반적으로는 지역 n 이 찾아진다
- 지역 n 은 int 의 경우 0초기화 된다 
ㄴ> g++ 의 경우 전역변수도 초기화 된다

- 전역변수 & 함수는 왠만하면 객체지향 프로그래밍으로는 객체들에게 유니버셜하게 미치는 영향을 막고자 자제해야 한다.




조건연산자

- 우선 사칙연산자와 마찬가지로, 조건연산이 서로 다른 타입의 operand 사이에 일어나게 되면 casting 이 발생한다.
- 그 규칙은 사칙 연산 떄와 마찬가지이다.

- 부동소수점 연산을 할 때에는, 항상 최하위 비트들의 오차에 대해 생각해야 한다.
- double 까지 가면 이 오차는 거의 필연적이다.
- 그래서 double 형의 조건연산을 할 땐 이런 괴리를 꼭 의식해야 한다.
- 가능한 부동소수점 조건연산을 피하는 것이 좋겠다.
ㄴ> 또는 Truncation 과정을 거치거나

- 






