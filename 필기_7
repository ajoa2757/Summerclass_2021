# Summerclass_2021



Call By Reference : 주소에 의한 호출, 포인터로 호출하며 스택에 포인터 공간만 생긴다

Call By Value : 매개변수의 크기 만큼의 메모리 공간이 스택에 실제로 할당이 된다. 즉 

- 요점은 실질적인 메모리 공간이 할당이 되냐 안되느냐의 차이라고 하겠다
- 당연히 CBR 이 훨씬 잘 쓰인다. 빠르고, 실질적 조작이 가능하기 때문에 매력적이다. 



참조자

- 최호성씨 강의에 따르면, 참조자를 사용하면 실제로 어딘가에 원본의 주소(포인터) 가 담기긴 한다.
- 단지 일반적 C 포인터 와는 다르게 포인터가 일편단심이다. 한번 지정되면 다른 것을 가리킬 수 없다 

- 또 하나 포인터와 다른 특수성 - main 에서 매개변수를 넘겨줄 때, 참조자 매개변수를 받는 함수는 원본을 집어넣으면 알아서 동작한다\
- 하지만 포인터를 매개변수로 받도록 만든 함수의 경우 원본을 넣으려고 하면 int vs int* 의 괴리가 일어나면서 오류를 일으킨다

- int* 와 같은 케이스와는 다르게, 어딘가에 담겨있는 원본의 주소의 위치는 우리는 특정할 수 없다. (특정을 할 수는 있다)

- 우리가 참조자를 조작하면, 값이 조작된다. 만약 포인터를 조작한다면, 주소데이터를 조작하는 짓을 하게 되었을 것이다.
- 참조자의 특이한 점은, 주소데이터를 조작할 수는 없게 되어있다는 것이다. 따라서 참조자에 대한 모든 조작은 원본의 값을 조작하는 동작이 된다


====함수 문법 관련====

함수의 Casting

- 사칙연산의 Casting 상황에서는, 정수는 소수로, 작은 것은 큰 것으로 캐스팅 되고는 했었다.
- return 이 integer 인 함수의 return 매개변수에 double 을 넘겨주게 되면, 반대로 int 로 Casting 되기도 한다.
- 이러한 Casting 은 C++ 표준에 있는 묵시적 형변환으로 보통 에러가 나지 아니한다

선언과 정의 분리

- 함수의 prototype '리턴타입 이름(매개변수리스트)' 을 정의라고 한다.
- 보통 main 이전에 함수가 선언되어야 main 이 함수를 가져다 쓸 수 있다.
- 다만 가독성 따위를 위해서, prototype 만 선제적으로 기술하고 정의는 그 아래에 따로 또 적어주는 것이 가능하다
- 이것은 헤더파일의 작동방식과 유사하다



매개변수의 전달과 에러에 대하여

- return 의 상황과 마찬가지로, 매개변수로 전달하는 상황도 묵시적 Casting 이 발생하기도 한다.
- 형변환이 허용되지 않는 Case 도 존재한다 (const 전달과 같은) 

- 같은 이름의 함수가 오버로딩 되어있는 경우, 캐스팅에 우선순위가 존재한다.
1. 가장 가까운 것 부터 찾는다
2. 그나마 바꿀 수 있는 것을 찾는다 (double <-> int)



- 디폴트 매개변수의 선언은 항상 오른쪽 먼저이다. 
- b(3) 을 보자. 
- 매개변수가 두개인데 디폴트가 1개 설정되어 있는 함수가 호출될 것인가?
- 매개변수가 int 한개인 함수가 호출 될 것인가?
- 모호성이 있어서 위험하다. 컴파일 에러.

- 오버로딩 되어 있는 서로 다른(이름만 같은) 함수가 서로를 호출하는 것도 합법이다. 




for 문의 반복인자에 대하여

- int i 가 for loop 내부에서 시작되었을 경우, 그 스코프를 벗어나면 사라진다.
- auto 에 대하여 알아야 함
- static 변수의 경우 : 지역적인 스코프에서 선언된다고 해도, static 은 계속해서 유지된다. 
ㄴ> 다만 지역변수에 오버로딩이 있다면 지역변수가 무조건 우선순위 높다 






