# Summerclass_2021

매우 중요한 클래스 내용이다



구조체와의 다른 점은 이러하다

- private 등의 레이블을 활용한 정보 캡슐화
ㄴ> 외부에서 직접적으로 접근할 수는 없도록 한다

- 따라서 메서드를 사용하여 간접적으로 접근하는 것 만을 허용하게 된다 
- 정해진 방법 이외로는 중요한 데이터에 간섭할 수 없도록 하는 것이 포인트



클래스 멤버 함수의 기술

- 클래스 안에도 간단한 함수는 구현할 수 있다. 하지만 선언과 정의를 분리할 수 있다.
- void classname::memberfunc(int var) 
ㄴ> 위와 같은 함수 레이블을 기술한 뒤에 정의한다. 요점은 함수 이름 앞에 클래스 이름을 네임스페이스 스코프 사용하듯이 해 주는 것

- 클래스 선언 스코프 내부에 정의하는 방식을 인라인 방식이라고 한다
- 인라인 방식으로 기술되어 있는 경우, jr $ra 를 사용하여 main 과 stack 을 오고가는 대신...
- 해당 inline 함수 안에 있는 n행을 기존의 흐름에 삽입한다. 즉 jr $ra 하지 아니한다.
ㄴ> 이 삽입 과정은 물론 컴파일 과정에 일어난다. 
ㄴ> 따라서, 실행 파일이 생성될 때 해당 부분의 실제 작업은 "함수 호출이 아니다"

- 이러한 인라인 처리는 작업의 효율에 영향을 끼칠 수 있다.
- 인라인을 하는 것이 나은지 아니면 하지 아니하는 것이 나은지는 지금 수준에서 판정하기는 무리
- 현대 컴파일러들은 스마트하기 때문에 ? 인라인 여부를, 키워드를 쓰건 말건 알아서 판정을 해버린다 

- 인라인 기법은 함수 호출에 대한 과한 오버헤드를 피하기 위해서, 짧은 코드를 대체하기 위해서 보통 사용한다.
ㄴ> 오버헤드는 jr $ra 등으로 인한 자원소모를 말한다
ㄴ> 김태간 교수의 생각 : 수준이 떨어지는 학교에는 컴파일러 같은 본질적으로 중요한 과목이 없을 확률이 크다 

- 생성자는 return 값을 기술 조차 하지 않는 다소 특수한 메소드라고 할 수 있다.
- 아무런 매개변수가 없는 것이 디폴트 생성자
- 초기화 리스트 라는 기법 : 함수 레이블 뒤에 ' ... :hp(60), attack(5) 와 같은 꼬리를 달아주고 정의를 계속한다. 

- 매개변수를 받는 생성자들 중에서도, 'onst class& s'와 같은 매개변수 하나를 받는 경우가 있다.
- 이것을 복사 생성자라고 한다. 

- 복사 생성자를 사용하는 경우, 게터와 세터를 따로 사용할 것 없이 멤버에 직접적으로 접근할 수 있는 듯 하다 ?
- 같은 클래스 내부에서는 접근 제한이 걸리지 아니하는 듯 하다


- 객체의 이름은 중복될 수 없다

- 다음주 영상수업의 내용을 요약하는 것이 출석과제
+ 그 범위까지가 퀴즈가 될 예정
+ 오픈북 아님, iclass

+ 선다형, 단답형, 짝짓기 등등
+ 공부 범위는 2 ~ 6장 







