# Summerclass_2021

포인터 i 

- 데이터의 주소를 가리키는 데이터 유형이다
- int* pNum = &a 과 같이 선언 및 초기화할 수 있다.
ㄴ>&a 는 a 의 포인터를 반환하는 연산자이다. pNum 은 자기만의 개별적인 주소에 위치하고, 다만 그 공간에 &a 가 자리하게 되는 것이다

- 선언하자 마자 초기화 해야 한다. 당장 넘겨줄 주소값이 없다면 nullptr 로 초기화 한다.

- 참조자의 경우, &연산자로 참조자 자체의 주소를 얻는 행위를 할 수 없다. 다만 오리지널의 주소만을 얻을 수 있을 따름이다


묵시적 문법

- const 포인터의 경우, 참조자와 성질이 반대에 있다.
- 참조자는 바인딩을 바꿀 수 없고 값을 바꿀 수 있다.
- const 포인터는 바인딩을 바꿀 수 있고 대신 const 때문에 값을 바꿀 수 없다.

- 만약 int* const 와 같이 사용한다면 어떨까
- 이때는 참조자와 마찬가지로 바인딩을 바꿀 수 없게 된다. 
- 하지만 이번엔 참조자처럼 바인딩되어있는 주소의 값을 바꿀 수 있게 된다.
ㄴ> 결정적으로 해당 포인터의 주소를 받고자 할 땐 포인터의 주소가 따로 출력되므로 참조자와는 확실히 다른 것이다 

- 마지막으로 양쪽에 모두 const 키워드를, 즉 두번 사용한다면 이번에는 값도 바꿀 수 없고 바인딩도 바꿀 수 없게 된다.



void 포인터

- 보통 포인터는 short* np 와 같이 가리키는 주소의 자료형을 명시하여 선언하도록 되어 있다.
- 이것을 따로 지정하지 않고 4바이트짜리 주소값을 저장하는 void 포인터에 무슨 객체든 주소를 담을 수 있다.

- 하지만 치명적인 오류는, 연산자 '*' 를 사용하여 참조하려고 할 때, void 포인터의 경우 그것을 참조할 수 없다. 
- 만약 이것을 int 를 참조하기 위해 사용하고 싶다면, 형변환(=캐스팅) 을 통해 가리키는 대상의 size 를 알려 주어야 한다.


pass by pointer

- Call by Reference ? 가 참조자를 매개변수로 주는 것이었다면 pass by pointer 는 함수에 객체를 전달할 때 매개변수를 포인터를 전달하는 것이다




배열 & 클래스 포인터 혼합

- 배열의 i 번째 element 의 주소를 &연산자를 사용하여 포인터에 담은 상황을 상정해 보자.
- ++ 연산자를 사용하여 포인터를 1 증가시켰다고 하자. 이제 포인터는 어디를 가리킬 것인가?
- ++연산자 이후 포인터는 단순+1 되는 것이 아니라, 포인터의 지정된 타입에 따라 i+1 번째 배열 원소를 가리키도록 연산된다
ㄴ> 즉 주소를 나타내는 16진수에 대하여 +1 이 아니라 +4 가 된다. 아마도 포인터 객체의 연산자 오버로딩?
ㄴ> void 포인터에 대한 ++ 연산은 어떨까 싶다 


ㄴ> integer 는 32비트 = 4바이트 데이터이다. 즉 여기서 +4 되고있는 주소값은 비트가 아니라 바이트 만큼의 크기에 해당한다.
ㄴ> 즉 주소 '1' 은 1바이트 = 8비트 만큼의 공간에 해당하는 것이다


- 배열의 이름은 배열이 시작하는 지점의 포인터처럼 사용될 수 있다. 
- 즉 "arr" 과 "&arr[0]" 은 정확히 같은 주소를 나타낸다. 

- 배열 포인터 : short (*psz)[n] = &arr 와 같이 선언한다.
ㄴ> 상기한 대로 보통 arr 과 같은 배열이름은 그 자체로 주소가 된다. 특이한 문법이라고 할 수 있겠다
ㄴ> (*psz)[i] 와 같은 방법으로 배열 arr 의 원소들에 엑세스 한다.

- 포인터 배열 : 말그대로 포인터로 구성된 배열들이다. 가령 주소록 같은 것을 상상하면 되겠다
- 포인터 배열을 순회하기 위한 포인터는 이중 포인터가 될 것이다 (포인터 배열의 주소는 이중 포인터가 될 것이므로)


객체 포인터

- 객체의 포인터를 사용할 수 있다. 그래봤자 단순 주소값이므로 크기는 4바이트이다 = 크기가 큰 객체를 CBR 로 가볍게 전달하기 용이하다
- 특히 객체 자기 자신을 가리키는 포인터를 멤버로 가지는 것이 가능하다. 각종 자료구조에서 한 데이터 단위를 'node' 로 나타낼 때 자주 보이는 활용이다
- 가령, node 와 node 가 일렬로 연결된 연결 리스트의 경우 노드들이 자기 자신과 같은 클래스의 포인터를 멤버변수로 하나씩 가지고 있다




메모리 관리

프로그램이 실행되고 메모리에 기록되는 것들은 다음과 같이 나눌 수 있다
- 코드 : 프로그램의 코드는 프로그램이 시작될 때 Fetch 되고 종료될 때 소거된다
ㄴ> $ra 를 통해 해당 메모리 영역에서 어떤 지점의 명령문이 실행되어야 하는지 통제된다 
- 정적 : 스코프를 벗어나면 소거되는 stack 메모리의 데이터들과는 다르게, static 키워드로 선언된 변수들. 아예 저장되는 영역이 다르다
- 스택 : 스코프 내부에 있는 지역변수 및 매개변수들이 이 영역에 쌓인다
ㄴ> 스코프가 종료되면서 Pop 된다 

- 힙 : 동적 메모리 할당을 통해 아래로 자라는 메모리
ㄴ> 스택 메모리와는 다르게 (아마도 컴파일 시점에 결정이 되는??)실행 중에 사이즈가 계속 달라질 수 있는 것이 특징이다



동적 메모리 할당

- malloc 을 사용하던 C 와 다르게 new 키워드를 사용한다 : int* arr = new int[m]
ㄴ> 이때 m 이 변수일 수 있다는 것이 기존 방법과의 가장 큰 차이점이다
ㄴ> '[]' 를 사용하여 특정 size 의 공간을 사용자 지정 갯수만큼 할당하는 것이 보인다
ㄴ> 새로이 할당한 주소를 포인터 a 가 받는 것이 보인다 : 이것은 배열과 같이 연속적으로 할당되어 있다.

- 동적할당한 이후에는 앞서 살펴본 배열의 포인터 조작 시와 동일하게 조작하면 된다

- 동적할당한 메모리는 사용이 끝난 후 delete 키워드로 반드시 해제 해 주어야 한다.
- int* arr 처럼 배열 형태로 할당한 공간의 경우, delete[] arr;  와 같이 [] 를 붙여 주어야 한다
ㄴ> 단일 변수는 delete a;

- 스택은 스코프가 종료되면 메모리 공간의 변수들이 알아서 pop 된다. 하지만 heap 에 할당된 변수들은 스코프가 끝나도 heap 영역에 계속 남아있게 된다
- 따라서 제때 heap 영역의 메모리를 해제 해 주지 않으면 메모리 누수가 일어날 것이다

(막간) 문자열 배열의 경우 배열이 끝나는 지점에 '\0' 이 반드시 존재해야 함을 꼭 기억하도록 한다
(막간) 계속해서 나오는 이야기지만 포인터는 가능한 nullptr 을 사용해서 초기화 된 상태를 지켜 주는 게 옳다



동적할당과 예외처리

- 어떤 지역함수에서 동적할당하고 delete 한다고 하자
- 만약, try & throw & catch 로 인한 흐름 탈출이, '동적할당 이후 & delete 이전' 에 일어나게 되면 그대로 메모리 누수가 일어나게 된다
- 





String 자료구조

- C 언어 : char 로 구성된 array 의 형태를 사용, cstring 라이브러리를 include 해야 한다 
- 길이 측정 : strlen 이라는 함수에 array 를 전달하는 방식으로 길이를 얻는다
- 복사 : length+1 (for NULL) 공간을 확보한 뒤, strcpy 함수를 통해 복사본을 얻는다
- 이어붙이기 : strcat 함수 사용하여 1번째 매개변수의 NULL 지점부터 이어붙여진다
- 비교연산 : strcmp 함수를 사용하여 앞쪽 인수가 더 크면 1 작으면 -1 둘이 같으면 0 리턴받는다
  


- C++ : string 이라는 자료구조를 사용
- 길이 측정 : s.size 메서드 사용
- 복사 : 대입연산자에 대해 오버로딩이 되어 있어서, 단순히 t = s 를 하면 string 과 string 을 서로 복사할 수 있다 
- 이어붙이기 : '+' 연산자가 직관적으로 오버로딩 되어있다
- 비교연산 : '==' 연산자가 직관적으로 오버로딩 되어있다


#pragma warning(disable:4996)

- 사실 C 스타일 함수 사용에서, 메모리를 안전하게 사용하기 위해 strcat_s 함수를 사용해야 한다.
- 하지만 이것은 비주얼스튜디오 컴파일러에서만 제공되는 함수이다. 좀 더 범용적인 코드를 사용하기 위해 strcat 함수를 사용해도 지장이 없도록 위 전처리기를 추가한 것이다



사용자 문자열 입력

C 스타일
- cin.getline(저장공간의_주소, 글자 갯수) 함수를 사용한다 
ㄴ> 입력한 "글자 갯수" -1 만큼의 char 를 입력받을 수 있다. NULL 문자를 넣기 위함

명확하게 하고 가기 : C 스타일 배열에서, cs[3] 과 같은 배열은 3바이트의 공간을 차지하며, 실제로 char 자료형이 자리를 잡을 수 있는 공간은 2바이트이다.
마지막 1바이트는 반드시 NULL 문자가 위치하며, 이것은 생성 시점에서부터 결정되는 것이다 


C++ 스타일
- getline(cin, 저장공간의_주소) 함수를 사용한다


*cin >> 을 사용하지 않는 이유가 있다
1. 사이즈 이상의 긴 문자열을 입력받았을 때 메모리 영역이 바로 침범당한다
ㄴ> getline 함수의 경우 영역을 넘어가는 입력은 잘라내고 받는다

ㄴ> 이러한 현상의 이유 : cin.getline 함수는 지정된 크기를 초과하는 문자가 cin 객체를 통해 받아지면..
- 우선 알맞은 크기로 잘라내고
- cin 의 상태를 'fail' 로 놓는다
- 그래서 이후의 cin 관련 코드가 제대로 동작하지 않게 된다.

- 이때 cin.clear(); 함수를 사용하면 fail 버퍼가 다시 비워지면서 다음 코드부터는 초과입력한 분량부터 입력이 시작되면서 코드가 제대로 동작하게 된다 


2. 공백문자를 입력받을 수 없다
ㄴ> cin 의 >>연산자는 공백문지를 delimiter 로 인식하기 때문에 공백문자를 입력받을 수 없다
ㄴ> getline 은 개행문자만을 delimiter 로 받는다 




