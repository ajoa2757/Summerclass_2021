# Summerclass_2021

포인터 i 

- 데이터의 주소를 가리키는 데이터 유형이다
- int* pNum = &a 과 같이 선언 및 초기화할 수 있다.
ㄴ>&a 는 a 의 포인터를 반환하는 연산자이다. pNum 은 자기만의 개별적인 주소에 위치하고, 다만 그 공간에 &a 가 자리하게 되는 것이다

- 선언하자 마자 초기화 해야 한다. 당장 넘겨줄 주소값이 없다면 nullptr 로 초기화 한다.

- 참조자의 경우, &연산자로 참조자 자체의 주소를 얻는 행위를 할 수 없다. 다만 오리지널의 주소만을 얻을 수 있을 따름이다


묵시적 문법

- const 포인터의 경우, 참조자와 성질이 반대에 있다.
- 참조자는 바인딩을 바꿀 수 없고 값을 바꿀 수 있다.
- const 포인터는 바인딩을 바꿀 수 있고 대신 const 때문에 값을 바꿀 수 없다.

- 만약 int* const 와 같이 사용한다면 어떨까
- 이때는 참조자와 마찬가지로 바인딩을 바꿀 수 없게 된다. 
- 하지만 이번엔 참조자처럼 바인딩되어있는 주소의 값을 바꿀 수 있게 된다.
ㄴ> 결정적으로 해당 포인터의 주소를 받고자 할 땐 포인터의 주소가 따로 출력되므로 참조자와는 확실히 다른 것이다 

- 마지막으로 양쪽에 모두 const 키워드를, 즉 두번 사용한다면 이번에는 값도 바꿀 수 없고 바인딩도 바꿀 수 없게 된다.



void 포인터

- 보통 포인터는 short* np 와 같이 가리키는 주소의 자료형을 명시하여 선언하도록 되어 있다.
- 이것을 따로 지정하지 않고 4바이트짜리 주소값을 저장하는 void 포인터에 무슨 객체든 주소를 담을 수 있다.

- 하지만 치명적인 오류는, 연산자 '*' 를 사용하여 참조하려고 할 때, void 포인터의 경우 그것을 참조할 수 없다. 
- 만약 이것을 int 를 참조하기 위해 사용하고 싶다면, 형변환(=캐스팅) 을 통해 가리키는 대상의 size 를 알려 주어야 한다.


pass by pointer

- Call by Reference ? 가 참조자를 매개변수로 주는 것이었다면 pass by pointer 는 함수에 객체를 전달할 때 매개변수를 포인터를 전달하는 것이다

