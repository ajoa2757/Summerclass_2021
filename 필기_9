# Summerclass_2021


수업시간에 배웠던 여러 생성자를 통해 만들어진 객체들이 있다.

- s1 & s2 : 아무런 매개변수 없는 디폴트 생성자 사용
- s3 : string 매개변수를 하나 받는 생성자 사용
ㄴ> 아래 s4 의 경우와는 다르게 초기값들이 직접대입된다 

- s4 : 복사 생성자를 통해 s3 의 멤벼번수들을 전달받은 객체
ㄴ> 특히, s3 객체의 데이터들을 초기화 리스트를 통해 복사한다.




소멸자 문법

- '~SCV' 와 같이 시작하여 소멸자를 정의한다. 매개변수도 반환값도 없는 또다른 특이한 메서드라고 할 수 있다.
- 보통 파일 입출력을 정리하고, 동적 메모리 할당을 해제할 때 소멸자를 이용하면 편리하다고 한다.

- 반드시 public 내부에 선언 되어야 한다
- 보통 시스템이 호출하지 사용자가 호출하지는 않는다.


- main 함수 내부에 별도의 스코프를 생성하고 cout 을 통해 소멸자의 호출타이밍을 관찰해 보았다.
- 스코프를 벗어나면서 소멸자가 호출되는 것이 관측되었다.
- 함수 스택이 풀리면서 지역변수가 사라지는 것과 거의 같은 맥락으로 보인다



static 멤버

- 정적 멤버변수 : 모든 객체가 공유하는 멤버변수이다 (가령 유닛의 인구수)
- 정적 멤버함수 : 모든 객체가 같이 쓰는 멤버함수이다.
ㄴ> 선언과 정의의 분리를 가정하였을 때, 선언부에만 static 키워드를 명시해 주면 정의에서는 굳이 필요치 않다

문법

static int count 
static void printSCVCount()

- 위와 같이 쓴다
- 



정적 멤버변수에 대하여

- 그 어떤 객체의 메서드를 통해서 조작하더라도 한 흐름이 계속 이어진다
- 유닛 인구수는, 모든 객체(유닛)들이 단일 인구수 변수를 증가시키고 또 감소시킨다.
- 이와 같이 모든 객체가 어떤 유일한 정적 멤버변수를 조작하게 된다.

정적 멤버함수에 대하여

- SCV::함수이름() 과 같이 사용한다. 


- 이는 static 멤버함수가 '객체'가 아니라 '클래스'에 구속된 함수이기 때문이다


파일 분할

- 본 과목에서 실습중인 SCV 객체를 예시로 들자면, 파일 분할은 아래 3종류로 이루어진다

헤더 파일(.h) : "인터페이스 역할" 을 한다고 한다. SCV 클래스의 멤버 함수들과 변수드르이 '선언' 되어 있다.
ㄴ> 이때, 한번 컴파일된 헤더파일이 중복으로 읽어지는 것을 방지하기 위해 전처리 지시문을 사용한다

멤버 함수 정의 파일(.cpp) : cpp 파일로, 헤더 파일에서 선언한 함수들의 실제 구체적 정의가 이 파일에서 이루어진다

main 함수 파일 : 마지막으로 main 함수가 포함되어 있는 cpp 파일로, 프로그램의 흐름은 main 함수에서 시작되고 끝난다 




헤더 파일 내용

- 기본적으로 앞서 선언한 구성들이 .h 파일에 들어간다
- 또한, #include <iostream> 과 같은 행도 들어간다
- using namespace std; 역시 마찬가지

- 이 헤더파일을 다른 .cpp 파일에서 사용할 땐
  #incldue "SCV.h" 와 같이 큰 따옴표를 사용한다.
  - 보통 같은 디렉토리 내부에서 헤더파일을 탐색할 때 큰 따옴표를 사용한다
  

정의 파일 내용

- 보통 헤더파일과 cpp 파일을 구성할 때에 , 객체 단위로 구성하는 듯 하다(가령 string 과 같은 자료구조 헤더)
- 그러므로 지금까지 만든 내용 중 정적 멤버변수와 함수를 포함한 SCV 객체와 직접적 연관이 있는 정의들만 정의 파일에 담는다
ㄴ> 즉 void f() 함수는 main 함수가 있는 cpp 파일로 옮겨진다

- 헤더파일은 마찬가지로 헤더파일을 include 해 주어야 한다


main 함수 파일 

- 마찬가지로 헤더파일을 include 해야 한다. 


전처리 지시문에 대하여

- 디폴트로는 #pragma once 가 제공된다
- 허나 다양한 환경에서 두루 사용되는 방법을 대신 배우도록 한다

- 만약 어떤 클래스의 정의를 가지고 있는 헤더 파일을 두번 include 했다고 하자
- 클래스 재정의 라는 이름의 오류가 일어난다. 이것을 방지하기 위해 #pragma once 와 같은 전처리 지시문을 사용하는 것이다 


- 헤더파일로 가서, 1행에 #ifndef 를 입력하면 자동완성되며 아래에 #endif 가 추가된다.
- ifndef 옆에 1이 추가되는데 이것을 지우고 관례대로 'SCV_H' 를 추가해준다. (클래스 이름_H)
- #ifndef 아래에 #define '클래스 이름_H' 을 추가하고, #endif 와 #define 사이에 헤더파일의 코드들을 작성한다. 

- incldue <> 를 사용하는 경우에는, STL 이 들어있는 디렉토리 내부에서 탐색된다.
- 앞에 c- 가 붙는 STL 헤더파일들은 C언어에서 사용되던 헤더들이다.






배열

- 자료형의 크기에 맞게 선언되고, 데이터들이 "연속적인 주소에" 배치되어 있다.
- 가령, int 형 배열은 4바이트 단위로 나열되는 식이다.

- 이를 확인하기 위해 '&' 연산자로 각 element 의 주소를 출력해 보면 4씩 거리를 두고 배치되어 있는 것을 확인할 수 있다
ㄴ> 특히 이때 주소 출력은 cout 에 hex 객체가 전달되지 않고도 그냥 16진법으로 출력된다 (0x 는 표기되지 아니한다)


암묵적 문법 몇가지

- 동적할당 하지 않은 배열의 경우 초기에 크기를 정해주게 된다. 이때, 원소를 정해진 크기보다 적게 전달해줄 경우, 앞에서부터 채워지고 뒷 공간은 0으로 초기화 된다
- 크기 지정 없이 우변에 {7, 2} 와 같이 초기화 해 주면, 크기 2의 배열로 알아서 설정된다 

- 만약 배열의 지정된 크기를 벗어나는 위치에 접근하려고 하면, 초기화도 무엇도 일어나지 않은 주소로부터 쓰레기값을 가져오게 된다.


- 지정된 횟수만큼 for 문을 통해 배열에 접근하는 경우, 나중에 배열의 크기를 바꾸거나 하였을 때 문제가 생길 수 있다.
- sizeof('배열이름') 을 사용하면 크기를 나중에 조작하더라도 그 부분에 대한 대응이 알아서 되는 코드를 짤 수 있다. 




객체의 배열

- 사용자 설정 클래스로 만든 객체들 역시 배열의 element 가 될 수 있다.
- 가령 선행하여 만든 SCV 객체 역시 배열로 만들 수 있다.

- int 배열을 {7, 2} 와 같이 선언 및 초기화 할 수 있었다.
- SCV 객체의 경우 생성자를 활용하여 {SCV(), SCV("문자열")} 과 같은 방식으로 선언 및 초기화 할 수 있다. 

- 기존 s1, s2 와 같이 직접 하나씩 이름을 붙여 주었던 방식과는 다르게, 배열로 선언된 객체의 경우 s[i] 와 같이 각 element 에 접근할 수 있다.
- 위의 좀 생소한 문법으로 초기화를 한번 해 주고 나서, s[i] 와 같은 이름을 사용하기 시작하면 거기서 부터는 사실상 일반적인 단일 객체를 다루는 것과 크게 다른 점이 없다






참조자

- 앞서 수업에서 포인터와의 유사점과 차이점을 가지고 설명을 들은 바 있다.

- 내부적으로는 어딘가에 포인터를 저장하긴 하므로 본질적으로 포인터의 아종이다.(=기만적인 참조) 다만 그 위치를 특정하기가 어려우며, 
- 문법적으로는 변수의 오리지널 이름을 그대로 갖다 쓰는 것과 별반 다르지 않은 작용을 하게 된다.
- 선언과 동시에 초기화가 되어야만 한다. 포인터와는 다르게 한번 참조자와 객체를 묶고 나면 그것을 바꿀 수 없다. (= 더 안전하다)
ㄴ> 대입연산자 '=' 를 사용하여 바인딩을 하는 것은 딱 초기 선언 시에만이다. 이후 사용되는 대입 연산자는 모두 오리지널의 값을 조작하는데 사용된다.
ㄴ> 즉 바인딩 시의 대입연산자 사용과 이후의 대입연산자 사용은 연산자만 같지 전혀 다른 작용을 한다고 할 수 있겠다.


- const 키워드를 앞에 붙여서 const int& 과 같이 사용하면 그 참조자를 가지고서는 오리지널의 값을 변경할 수 없게 된다.
(막간) & 연산은 본래 2진수 비트패턴의 모든 비트들을 서로 and 연산 한 결과를 출력하게 된다 
(막간) & 연산을 객체 앞에 붙여 사용하면 본래 객체의 주소를 나타내게 된다. 이때 cout 은 기본적으로 16진수를 출력하게 된다.



Call by Reference

- 함수에 매개변수가 전달되는 과정을 생각해 보자.
- stack 위에 매개변수 객체들이 새로 선언되어 쌓인다. 그리고 그 안에는 전달된 value 들이 들어간다.

- 이때 데이터가 가지고 있는 값이 매개변수에 들어가는 상황을 생각해 보자. 이것은 원본의 현 상태와는 전혀 연관이 없으며, 함수가 호출 될 당시의 값만 가져온 복사본일 뿐이다.

- 또 다른 상황은, 데이터가 위치한 주소가 전달되는 경우이다.
- 이것을 call by reference 라고 부른다. stack 에 기록되어 있는 주소로 가서 조작을 하게 되면, 함수 호출 당시 전달된 원본을 정말로 조작하는 것이 된다.



- C언어에서 CBR 은 포인터를 통해서만 이루어질 수 있었다.
- 하지만 C++에는 참조자가 있다. 참조자는 사용할 땐 변수의 오리지널 이름을 갖다 쓰는 것과 별반 다르지 않은 작용을 했었다.
ㄴ> 매개변수가 전달될 때도 Call By value 를 할때와 같은 방식으로 전달된다. 그래서 사용자 입장에선 해당 함수가 CBR 인지 CBV 인지 모르고 사용할 수 있다.

- 매개변수로 전달될 때는, 앞서 이것이 다소 기만적이지만 참조라는 표현을 사용하였듯이, CBV 가 아니라 CBR 로 작용한다. 

- CBR 의 또다른 장점은, stack 에 공간을 많이 차지하지 않는다는 점이다. 4바이트 int 와는 다르게, 다소 큰 사용자 정의 객체를 함수에 매개변수로 전달한다고 생각해 보자.
- 원본의 조작 용이성을 제쳐두더라도, Call By Value 를 하려면 객체의 크기를 통째로 스택에 새로 생성하여야 한다.
- 하지만 Call By Reference 를 하면, 4바이트 포인터만 stack 에 새로 쌓이게 되는 것이다. 이는 공간복잡도와 시간복잡도 모두에 큰 이점을 가져온다 



레퍼런스와 const

- 만약 매개변수를 전달하고는 싶은데, 그것을 통한 값의 변경(가령 C에서 포인터를 통한 CBR 를 했을때와 같은) 은 원하지 않는다고 해 보자.
- 참조자가 선언될 때 앞에 const 키워드가 붙는다면, 해당 참조자를 통해 오리지널의 값을 변경하는 것은 불가하게 된다.
ㄴ> 다만 원본의 이름을 사용한 조작은 여전히 가능하다 다만 참조자를 통한 조작이 불가능할 뿐이다 

- 만약 매개변수에 const 참조자를 사용한 전달을 하면, 별도의 조작은 불가능하지만 공간을 절약한 전달의 목적만 만족시키는 호출을 할 수 있는 것이다.
- 즉, 원본 보호의 목적과 복사비용 절약 두가지 이점을 모두 얻을 수 있는 것이다 
ㄴ> 원본을 직접 조작하는 함수가 필요할 땐 const 키워드를 빼면 그만일 것이다
ㄴ> 별도의 조작이 불가능하도록 막아 놓은 것은 가능한데 하지 않는 것과 큰 차이가 있다 

Q. 함수의 선언 시에 행의 끝에 const 를 쓰는 경우와 어떤 것이 다를까?
A. 함수 뒤에 붙는 const 는 함수가 멤버 함수일 시에만 사용할 수 있는 함수이다. 이런 함수는 멤버 변수를 비롯한 어떤 변수도 변경할 수 없도록 되어 있으며, 이 함수가 다른 함수를 call 할 때에도 const 함수만을 call 할 수 있다.




















